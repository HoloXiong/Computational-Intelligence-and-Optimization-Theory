# 小孩分油问题
## 问题
小孩分油问题：两个小孩去打油，一人带了一个一斤的空瓶，另一个带了一个七两、一个三两的空瓶。原计划各打一斤油，可是由于所带的钱不够，只好两人合打了一斤油，在回家的路上，两人想平分这一斤油，可是没有其它工具。试仅用三个瓶子(一斤、七两、三两)精确地分出两个半斤油来。
## 分析
假设A（容量为10两），B（容量为7两），C（容量为3两）表示三个油瓶，则依据题意可以转化为状态（A，B，C）=（10，0，0）==>（5，5，0）。由于BC两个瓶子总容量为10，因此可以将A视为一个无穷大的油桶（可以一直倒油），则上述问题转化为（B，C）=（0，0）==>（5，0）。
| 编号   | 规则  | 描述 |
| :-----: | :----: | :----: |
| 1   | B<7 (B,C)==>(7,C)  |  A倒满B |
| 2   | C<3 (B,C)==>(B,C)  | A倒满C  |
| 3   |  B>0 (B,C)==>(0,C) |  倒空B到A |
| 4   |  C>0 (B,C)==>(B,0) |  倒空C到A |
| 5   | B>0 B+C<=3 (B,C)==>(0,B+C)  | 倒空B到C  |
| 6   | C>0 B+C<=7 (B,C)==>(B+C,0)  |  倒空C到B |
| 7   |  C<3 B+C>=3 (B,C)==>(B+C-3,3) | B倒满C  |
| 8   |  B<7 B+C>=7 (B,C)==>(7,B+C-7) |  C倒满B |
## dfs解决
这里使用Python语言实现深度优先搜索步骤如下：

（1）设计实现类OilState用于实例化每个状态对象（B，C），表示当前状态下的7两和3两油瓶的油量

（2）设计实现函数is_visited，判断状态是否出现过

（3）设计实现函数pour，模拟倒油的过程，在状态未出现过的情况下进行按照8种规则进行倒油

（4）设计实现函数dfs，利用列表作为栈，存储搜索过程中出现的状态，设计一个visited列表，存储出现过的状态，避免状态重复。按照设计的规则进行倒油问题的搜索，当达到目标状态时结束搜索

（5）主函数执行dfs
## bfs解决
使用Python语言实现分油问题的广度优先搜索，算法步骤如下：

（1）设计实现类OilState用于实例化每个状态对象（B，C，pre），表示当前状态下的7两和3两油瓶的油量，pre表示当前结点的前驱，用于倒油路径的输出

（2）设计is_visited函数，判断当前油量状态是否已经搜索过

（3）设计bfs函数，利用队列deque，将当前状态结点所有可能出现的状态入队，然后在队列不为空的情况下循环从队首开始访问，队首出队，判断是否到达目标状态，到达则将路径回溯打印并退出。未达到目标状态则继续将接下来所有状态入队，继续搜索

（4）主函数执行bfs()
> note：如有谬误，敬请指正